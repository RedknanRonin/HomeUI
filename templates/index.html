<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>Home</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            height: 100vh;
            background-color: #f0f0f0;
        }
        .container {
            text-align: center;
        }
        .btn {
            padding: 10px 20px;
            font-size: 18px;
            cursor: pointer;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            text-decoration: none;
            margin-top: 20px;
        }
        .btn:hover {
            background-color: #0056b3;
        }
        .canvas-container {
            display: flex;
            justify-content: space-around;
            width: 100%;
        }
        .template {
            text-align: center;
        }
        #gridCanvas1, #gridCanvas2 {
            border: 1px solid black;
            background: #f0f0f0;
            margin-top: 20px;
        }
    </style>
</head>
<body>

<div class="container">
    <h1>Welcome to the House Outline App</h1>
    <div class="canvas-container">
        <div class="template">
            <h2 id="templateName1">Template 1</h2>
            <canvas id="gridCanvas1" width="400" height="300"></canvas>
        </div>
        <div class="template">
            <h2 id="templateName2">Template 2</h2>
            <canvas id="gridCanvas2" width="400" height="300"></canvas>
        </div>

    </div>
    <div class="chart-container" style="position: relative; height:40vh; width:80vw">
        <canvas id="hourlyPriceChart"></canvas>

    </div>
    <div class="bus-container">
     <h1> Next busses towards city center</h1>
    </div>



    </div>
    <a href="/settings" class="btn">Settings</a>
</div>
<div id="colors">
    <div id="red" class="color"></div>
    <div id="green" class="color"></div>
    <div id="blue" class="color"></div>
    <div id="yellow" class="color"></div>
    <div id="orange" class="color"></div>
    <div id="purple" class="color"></div>
</div>
<script>
    var config = {{ config | tojson }};

    async function getPriceForHourToday(hour){
        const PRICE_ENDPOINT = 'https://api.porssisahko.net/v1/price.json';
        const dateAndTimeNow = new Date();
        const year = dateAndTimeNow.getFullYear();
        const month = dateAndTimeNow.getMonth() + 1;
        const day = dateAndTimeNow.getDate();

        const twoDigits = (number) => (number < 10 ? `0${number}` : `${number}`);

        const params = `date=${year}-${twoDigits(month)}-${twoDigits(day)}&hour=${twoDigits(hour)}`;
        const response = await fetch(`${PRICE_ENDPOINT}?${params}`);
        const { price } = await response.json();
        console.log(`The price is now ${price}`);
        return price;}
    //requires anti cors measures on localhost

    elecPrice=async function (){
        const prices = [];
        const hours = [];
        for (let i = 0; i < 24; i++) {
            hours.push(`${i}:00`);
            // Assuming getPriceForHourToday returns a promise that resolves with the price
            const price = await getPriceForHourToday(i);
            prices.push(price);
        }

        const ctx = document.getElementById('hourlyPriceChart').getContext('2d');
        const hourlyPriceChart = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: hours,
                datasets: [{
                    label: 'Sähkön hinta snt/kWh',
                    data: prices,
                    fill: true,
                    borderColor: 'rgb(175, 192, 192)',
                    backgroundColor: 'rgb(40,173,173)',
                    tension: 0.1
                }]
            },
            options: {
                scales: {
                    y: {
                        beginAtZero: true
                    }
                }
            }
        });}

    window.onload = function() {
        elecPrice(); // Called  immediately on load

        function calculateDelayUntilSetTime(hour) {
            const now = new Date();
            const next = new Date(now);
            next.setHours(hour, 0, 0, 0); // Set the next time to the desired hour

            // If the next time is already past, set it for the next day
            if (next <= now) {
                next.setDate(next.getDate() + 1);
            }

            return next - now; // Return the delay in milliseconds
        }

        function queryPriceAtSetTime(hour) {
            const delay = calculateDelayUntilSetTime(hour);

            setTimeout(function() {
                elecPrice(); // Call your query function

                // Then set it to repeat every 24 hours
                setInterval(elecPrice, 86400000); // 24 hours in milliseconds
            }, delay);
        }

        queryPriceAtSetTime(14);


        const drawings = {{ drawings | tojson }};
        const canvas1 = document.getElementById('gridCanvas1');
        const context1 = canvas1.getContext('2d');
        const canvas2 = document.getElementById('gridCanvas2');
        const context2 = canvas2.getContext('2d');
        const selectedTemplate1 = '{{ selected_templates[0] if selected_templates|length > 0 else "" }}';
        const selectedTemplate2 = '{{ selected_templates[1] if selected_templates|length > 1 else "" }}';
        const templateName1 = document.getElementById('templateName1');
        const templateName2 = document.getElementById('templateName2');

        function drawGrid(context, width, height, gridSize = 20) {
            context.strokeStyle = '#ddd';
            for (let x = 0; x <= width; x += gridSize) {
                context.moveTo(x, 0);
                context.lineTo(x, height);
            }
            for (let y = 0; y <= height; y += gridSize) {
                context.moveTo(0, y);
                context.lineTo(width, y);
            }
            context.stroke();
        }

        function addRectangleClickListener(canvas, rectangles) {
            canvas.addEventListener('click', function(event) {
                const x = event.offsetX;
                const y = event.offsetY;
                rectangles.forEach(rect => {
                    if (x >= rect.startX && x <= rect.startX + rect.width && y >= rect.startY && y <= rect.startY + rect.height) {
                        fetch('/api_request/' +rect.color, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({ color: rect.color })
                        })
                            .then(response => response.json())
                            .then(data => {
                                if (data.status === 'success') {
                                    alert('API request sent successfully!');
                                } else {
                                    alert('Failed to send API request.');
                                }
                            });
                    }
                });
            });
        }

        if (selectedTemplate1) {
            const drawing1 = drawings.find(drawing => drawing.name === selectedTemplate1);
            if (drawing1) {
                templateName1.textContent = drawing1.name;
                initializeCanvas(canvas1, context1, drawing1.rectangles);
                addRectangleClickListener(canvas1, drawing1.rectangles);  // Add this line
            }
        }

        if (selectedTemplate2) {
            const drawing2 = drawings.find(drawing => drawing.name === selectedTemplate2);
            if (drawing2) {
                templateName2.textContent = drawing2.name;
                initializeCanvas(canvas2, context2, drawing2.rectangles);
                addRectangleClickListener(canvas2, drawing2.rectangles);  // Add this line
            }
        }
        function drawRectangles(context, rectangles) {
            rectangles.forEach(rect => {
                context.fillStyle = rect.color;
                context.fillRect(rect.startX, rect.startY, rect.width, rect.height);
            });
        }

        function initializeCanvas(canvas, context, rectangles) {
            context.clearRect(0, 0, canvas.width, canvas.height);
            drawGrid(context, canvas.width, canvas.height);
            drawRectangles(context, rectangles);
        }

        if (selectedTemplate1) {
            const drawing1 = drawings.find(drawing => drawing.name === selectedTemplate1);
            if (drawing1) {
                templateName1.textContent = drawing1.name;
                initializeCanvas(canvas1, context1, drawing1.rectangles);
            }
        }

        if (selectedTemplate2) {
            const drawing2 = drawings.find(drawing => drawing.name === selectedTemplate2);
            if (drawing2) {
                templateName2.textContent = drawing2.name;
                initializeCanvas(canvas2, context2, drawing2.rectangles);
            }
        }

        function updateBusContainer(itineraries) {
            const container = document.querySelector('.bus-container');
            container.innerHTML = '<h1>Next buses towards city center</h1>'; // Reset container content

            itineraries.forEach((itinerary, index) => {
                const itineraryElem = document.createElement('div');
                itineraryElem.classList.add('itinerary');

                let itineraryHtml = `<h2>Itinerary ${index + 1}</h2><ul>`;
                itinerary.legs.forEach(leg => {
                    if (leg.trip!=null) {
                    const startTime =  new Date(itinerary.startTime).toLocaleTimeString().split(".");
                    const busLeavesTime = new Date(leg.startTime).toLocaleTimeString().split(".");
                    itineraryHtml += `
                <li>
                    <strong>${leg.trip.routeShortName}</strong>
                    <br> From home: <strong>${startTime[0]}:${startTime[1]}</strong>
                    <br> Bus leaves at ${busLeavesTime[0]}:${busLeavesTime[1]} from ${leg.from.name}
                </li>`;
                };
                 });
                itineraryHtml += '</ul>';
                itineraryElem.innerHTML = itineraryHtml;

                container.appendChild(itineraryElem);
            });
                }
        async function fetchBusItineraries() {
                    const query = `
                {
              plan(
                from: {lat: ${config.coordinates.from.lat}, lon: ${config.coordinates.from.lon}}
                to: {lat: ${config.coordinates.to.lat}, lon: ${config.coordinates.to.lon}}
                numItineraries: 3
              ) {
                itineraries {
                    startTime
                  legs {
                    trip {
                      tripHeadsign
                      routeShortName
                    }
                    startTime
                    from {
                      name
                    }
                  }
                }
              }
            }`;

            try {
                const response = await fetch('https://api.digitransit.fi/routing/v1/routers/finland/index/graphql', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'digitransit-subscription-key':config.digitransitApiKey
                    },
                    body: JSON.stringify({ query })
                });
                const { data } = await response.json();

                updateBusContainer(data.plan.itineraries);

                // Find the earliest startTime among the first legs of the itineraries
                const earliestStartTime = data.plan.itineraries
                    .map(itinerary => new Date(itinerary.legs[0].startTime).getTime())
                    .sort()[0];

                // Calculate the delay until the earliest startTime
                const now = new Date().getTime();
                const delay = earliestStartTime - now;

                // Set a timeout to fetch the next bus itineraries
                if (delay > 0) {
                    setTimeout(fetchBusItineraries, delay);
                }
            } catch (error) {
                alert(error)
                console.error('Failed to fetch bus itineraries:', error);
            }
        }



        // Call the function to fetch and display bus itineraries
        fetchBusItineraries();

        drawGrid(context1, canvas1.width, canvas1.height);
        drawGrid(context2, canvas2.width, canvas2.height);
    };
</script>
</body>
</html>
